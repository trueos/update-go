package trains

import (
	"bufio"
	"crypto"
	"crypto/rsa"
	"crypto/sha512"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"errors"
	"github.com/gorilla/websocket"
	"github.com/trueos/sysup/defines"
	"github.com/trueos/sysup/ws"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"
)

// Load the trains from remote
func loadtrains() (defines.TrainsDef, error) {

	// Create our JSON struct
	s := defines.TrainsDef{}

	if defines.TrainsUrl == "" {
		ws.SendMsg(
			"No train URL defined in JSON configuration: "+
				defines.ConfigJson,
			"fatal",
		)
		return s, errors.New("ERROR")
	}

	//sendinfomsg("Fetching trains configuration")
	resp, err := http.Get(defines.TrainsUrl)
	if err != nil {
		ws.SendMsg("Failed fetching "+defines.TrainsUrl, "fatal")
		return s, errors.New("ERROR")
	}

	// Cleanup when we exit
	defer resp.Body.Close()

	// Load the file into memory
	dat, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		ws.SendMsg("Failed reading train file!", "fatal")
		return s, errors.New("ERROR")
	}

	// Now fetch the sig
	//sendinfomsg("Fetching trains signature")
	sresp, serr := http.Get(defines.TrainsUrl + ".sha1")
	if serr != nil {
		ws.SendMsg("Failed fetching "+defines.TrainsUrl+".sha1", "fatal")
		return s, errors.New("ERROR")
	}

	// Cleanup when we exit
	defer sresp.Body.Close()

	// Load the file into memory
	sdat, err := ioutil.ReadAll(sresp.Body)
	if err != nil {
		ws.SendMsg("Failed reading train signature file!", "fatal")
		return s, errors.New("ERROR")
	}

	// Load the PEM key
	trainpub, terr := loadtrainspub()
	if terr != nil {
		ws.SendMsg("Failed to load train pubkey!", "fatal")
		return s, errors.New("ERROR")
	}
	block, _ := pem.Decode(trainpub)
	if block == nil || block.Type != "PUBLIC KEY" {
		ws.SendMsg("failed to decode PEM block containing public key", "fatal")
		return s, errors.New("ERROR")
	}

	// Get the public key from PEM
	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		ws.SendMsg("Failed to parse pub key", "fatal")
		return s, errors.New("ERROR")
	}

	hashed := sha512.Sum512(dat)

	// Now verify the signatures match
	err = rsa.VerifyPKCS1v15(
		pub.(*rsa.PublicKey), crypto.SHA512, hashed[:], sdat,
	)
	if err != nil {
		ws.SendMsg("Failed trains verification!", "fatal")
		return s, errors.New("ERROR")
	}

	// Lets decode this puppy
	if err := json.Unmarshal(dat, &s); err != nil {
		ws.SendMsg("Failed JSON parsing of train file!", "fatal")
		return s, errors.New("ERROR")
	}

	// Get the default train
	deftrain, terr := getdefaulttrain()
	if terr == nil {
		s.Default = deftrain
	}

	return s, nil
}

// Get trains and reply
func DoTrainList() {
	trains, err := loadtrains()
	if err != nil {
		return
	}
	sendtraindetails(trains)
}

// Send back details about the train
func sendtraindetails(trains defines.TrainsDef) {
	type JSONReply struct {
		Method  string             `json:"method"`
		Trains  []defines.TrainDef `json:"trains"`
		Default string             `json:"default"`
	}

	data := &JSONReply{
		Method:  "listtrains",
		Trains:  trains.Trains,
		Default: trains.Default,
	}
	msg, err := json.Marshal(data)
	if err != nil {
		log.Fatal("Failed encoding JSON:", err)
	}
	if err := defines.WSServer.WriteMessage(
		websocket.TextMessage, msg,
	); err != nil {
		log.Fatal(err)
	}
}

func getdefaulttrain() (string, error) {
	var deftrain string
	fileHandle, err := os.Open("/etc/pkg/Train.conf")
	if err != nil {
		return deftrain, err
	}
	defer fileHandle.Close()
	fileScanner := bufio.NewScanner(fileHandle)

	for fileScanner.Scan() {
		line := fileScanner.Text()
		if strings.Contains(line, "# TRAINNAME ") {
			linearray := strings.Split(line, " ")
			if len(linearray) < 2 {
				continue
			}
			deftrain = strings.TrimSpace(linearray[2])
			break
		}
	}

	return deftrain, nil
}

// Load the default trains pub key we use to verify JSON validity
func loadtrainspub() ([]byte, error) {
	var dat []byte
	// Try to load the default config file
	if _, err := os.Stat(defines.TrainPubKey); os.IsNotExist(err) {
		return dat, err
	}

	// Load the file into memory
	dat, err := ioutil.ReadFile(defines.TrainPubKey)
	if err != nil {
		log.Println("Failed reading train pubkey: " + defines.TrainPubKey)
		return dat, err
	}
	return dat, nil
}

func createnewpkgconf(train defines.TrainDef) {
	// Nuke existing pkg configs
	cmd := exec.Command("/bin/sh", "-c", "rm -f /etc/pkg/*.conf")
	cmd.Run()

	// Write the new key file
	var kdata []string
	for i := range train.PkgKey {
		kdata = append(kdata, train.PkgKey[i])
	}
	ioutil.WriteFile(
		"/usr/share/keys/train-pkg.key", []byte(strings.Join(kdata, "\n")),
		0644,
	)

	// Write the new conf file
	fdata := `# TRAINNAME ` + train.Name + `
# Generated by sysup: Do not modify directly
# Use "sysup -list-trains" and "sysup -change-train <trainname>" to modify.

` + train.Name + `: {
  url: "` + train.PkgURL + `",
  signature_type: "pubkey",
  pubkey: "/usr/share/keys/train-pkg.key",
  enabled: yes
}
`
	ioutil.WriteFile("/etc/pkg/Train.conf", []byte(fdata), 0644)

}

func DoSetTrain(message []byte) {
	// Get the new train name from JSON
	var s struct {
		defines.Envelope
		defines.SendReq
	}
	if err := json.Unmarshal(message, &s); err != nil {
		log.Fatal(err)
	}
	var newtrain = s.Train

	// Load the current train list
	trainlist, err := loadtrains()
	if err != nil {
		return
	}

	var foundt = -1
	trains := trainlist.Trains
	for i := range trains {
		if trains[i].Name == newtrain {
			foundt = i
			break
		}
	}
	if foundt == -1 {
		ws.SendMsg("Invalid train specified: "+newtrain, "fatal")
		return
	}

	// Sanity check
	if trains[foundt].PkgURL == "" {
		ws.SendMsg("Train missing PkgURL", "fatal")
		return
	}

	// Set the new train config file
	createnewpkgconf(trains[foundt])

	// Send back confirmation
	type JSONReply struct {
		Method string `json:"method"`
		Train  string `json:"train"`
	}

	data := &JSONReply{
		Method: "settrain",
		Train:  newtrain,
	}
	msg, err := json.Marshal(data)
	if err != nil {
		log.Fatal("Failed encoding JSON:", err)
	}
	if err := defines.WSServer.WriteMessage(
		websocket.TextMessage, msg,
	); err != nil {
		log.Fatal(err)
	}

}
